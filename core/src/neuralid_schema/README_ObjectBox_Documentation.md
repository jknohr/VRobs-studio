How to get started
ObjectBox Generator produces binding code for ObjectBox C & C++ APIs. This greatly simplifies the model declaration and FlatBuffers serialization, allowing you to concentrate on the application logic.

Generating binding code
info
ObjectBox Generator is a tool, which must be downloaded separately. For details, please check the installation page.

ObjectBox Generator uses FlatBuffer schema file (.fbs) as its primary input. The Generator also maintains some metadata around the data model in a JSON file (objectbox-model.json). Based on these two files, it generates code for the selected language (C or C++).

Let’s have a look at a sample schema and how Generator helps us.

tasklist.fbs
table Task {
    id: ulong;
    text: string;
    date_created: ulong;
    date_finished: ulong;
}

Use CMake or launch the following command to generate the binding code from the FlatBuffers schema file:

CMake (C++)
C++
C
find_package(ObjectBoxGenerator 4.0.0 REQUIRED)
add_obx_schema(TARGET myapp SCHEMA_FILES tasklist.fbs INSOURCE)

The following files will be generated:

objectbox-model.h
objectbox-model.json
tasklist.obx.hpp
tasklist.obx.cpp
info
See #cmake-supportfor details on CMake integration.

warning
You should add all these generated files to your source control (e.g. git), most importantly objectbox-model.json which ensures compatibility with previous versions of your database after you make changes to the schema.

Working with Object Boxes
Bet you wondered where our name comes from :)

From an ObjectBox Store, you get Box instances to manage your entities. While you can have multiple Box instances of the same type (for the same Entity) "open" at once, it's usually preferable to just use one instance and pass it around your code.

Now, you can include the generated headers in your application and start working with your database. Consider the following main file:

C++
C
main.cpp
#define OBX_CPP_FILE
#include "objectbox.hpp"
#include "objectbox-model.h"
#include "tasklist.obx.hpp"

int main(int argc, char* args[]) {
    // create_obx_model() provided by objectbox-model.h
    // obx interface contents provided by objectbox.hpp
    obx::Store store(create_obx_model());
    obx::Box<Task> box(store);

    obx_id id = box.put({.text = "Buy milk"});  // Create
    std::unique_ptr<Task> task = box.get(id);   // Read
    if (task) {
        task->text += " & some bread";
        box.put(*task);                         // Update
        box.remove(id);                         // Delete
    }
    return 0;
}

info
It's required to have exactly one .cpp file in your project that defines OBX_CPP_FILE right before the inclusion of the "objectbox.hpp" header.

This #define instructs the "objectbox.hpp" header to emit implementation definitions. If you accidentally have it in multiple files, the linker will complain about multiple symbols (having the same name).

If you've followed the installation instructions, you should be able to compile the example

If you are using CMake, like shown in the installation section, just add the generated tasklist.obx.cpp file to the myapp target.

The add_executable call in the CMake file now looks like this:

add_executable(myapp main.cpp tasklist.obx.cpp)

The rest of the CMakeLists.txt file stays unchanged. You can now use CMake as expected.

If you use a build system other than CMake, it has to do the proper action so the generated file is added to the build.

C++
C
g++ main.cpp tasklist.obx.cpp -I. -std=c++11 -lobjectbox

info
The command snippet assumes you have the libraries installed in a path recognized by your OS (e.g. /usr/local/lib/) and all the referenced headers are in the same folder alongside the main.c/.cpp file.

Wherever you have access to a Box, you can use it to persist objects and fetch objects from disk. Boxes are thread-safe. Here are some of the basic operations, have a look at the objectbox.h(pp) for more:

put: persist an object at the given ID: either creating a new one or overwriting an existing one.
get: read an object from the database. There's also a variant that takes a list of IDs as an argument and returns multiple objects.
remove: deletes a previously persisted object from its box.
count: the number of objects stored in this box.
Examples
Have a look at the following TaskList example apps, depending on your programming language and preference:

C, cursor, no generated code - plain C; using flatcc directly; without any generated code
C, with generated code - plain C, using code generated by objectbox-generator
C++, with generated code - C++, using code generated by objectbox-generator

Entity Annotations
ObjectBox database persistence for C and C++ is based on objects. Learn how to persist entities with entity annotations in this tutorial section.

The source FlatBuffer schema can contain some ObjectBox-specific annotations, declared as specially formatted comments to table and field FlatBuffer schema elements.

Annotated schema example
Have a look at the following FlatBuffers schema example showing some ObjectBox annotations:

schema.fbs
/// This entity is not annotated and serves as a relation target in this example
table Simple {
    id:ulong;
}

/// objectbox: name=AnnotatedEntity
table Annotated {
    /// Objectbox requires an ID property. Recognized automatically 
    /// if it has a right name ("id"), otherwise it must be annotated.
    /// objectbox:id
    identifier:ulong;

    /// objectbox:name="name",index=hash64
    fullName:string;

    /// objectbox:id-companion, date
    time:int64;

    /// objectbox:transient
    skippedField:[uint64];

    /// objectbox:relation=Simple
    relId:ulong;
}

/// This entity is synchronized between clients.
/// Requires ObjectBox Sync (see below and https://objectbox.io/sync/)
/// objectbox:sync
table SharedInfo {
    id:ulong;
    
    ...
}


Annotation format
To ensure that the annotations are recognized, follow these guidelines:

Supported annotations
The following annotations are currently supported:

Entity annotations
name - specifies the name to use in the database if it's desired to be different than what the FlatBuffer schema "table" is called.
transient - this entity is skipped, no code is generated for it. Useful if you have custom FlatBuffer handling but still want to generate ObjectBox binding code for some parts of the same file.
uid - used to explicitly specify UID used with this entity; used when renaming entities. See Schema changes for more details.
relation - adds a standalone (many-to-many) relation, usually to another entity. Example: creating a relation to the authors of a book: objectbox:relation(name=authors,to=Author)
sync - enables synchronization for the entity - only relevant with ObjectBox Sync library builds. Entities not marked with this annotation will not be synchronized to the server, i.e. they're local-only.
sync(sharedGlobalIds) can be used to switch from the default behaviour (ID-mapping) to using a global ID space. This flag tells ObjectBox to treat object IDs globally and thus no ID mapping (local <-> global) is performed. Often this is used with id(assignable) annotation and some special ID scheme.
Property annotations
date - tells ObjectBox the property is a timestamp in milliseconds, ObjectBox expects the value to be the number of milliseconds since UNIX epoch.
date-nano - tells ObjectBox the property is a timestamp in nanoseconds, ObjectBox expects the value to be the number of nanoseconds since UNIX epoch.
id - specifies this property is a unique identifier of the object - used for all CRUD operations.
assignable IDs (set as id(assignable)) to switch from the default (ObjectBox assigns object IDs during insert, following auto-increment order). This will allow putting an object with any valid ID. You can still set the ID to zero to let ObjectBox auto-assign a new ID.
id-companion - identifies a companion property, currently only supported on date/date-nano properties in time-series databases.
index - creates a database index. This can improve performance when querying for that property. You can specify an index type as the annotation value:
not specified - automatically choose the index type based on the property type (hash for string, value for others).
value - uses property values to build the index. For string, this may require more storage than a hash-based index.
hash - uses a 32-bit hash of property value to build the index. Occasional collisions may occur which should not have any performance impact in practice (with normal value distribution). Usually, a better choice than hash64, as it requires less storage.
hash64 - uses a long hash of property values to build the index. Requires more storage than hash and thus should not be the first choice in most cases.
relation - declares the field as a relation ID, linking to another Entity which must be specified as a value of this annotation.
name - specifies the name to use in the database if it's desired to be different than what the FlatBuffer schema "field" is called.
transient - this property is skipped, no code is generated for it. Useful if you have custom FlatBuffer handling but still want to generate ObjectBox binding code for the entity.
uid - used to explicitly specify UID used with this property; used when renaming properties. See Schema changes for more details.
unique - set to enforce that values are unique before an entity is inserted/updated. A put operation will abort and return an error if the unique constraint is violated.


Generator
This is the reference guide on the ObjectBox Generator, a build-time tool for ObjectBox.

info
For an intro to the generator, see also the installation guide and Generating Binding Code.

When using ObjectBox within your project, you typically need two things: the runtime library and the build-time ObjectBox Generator. The generator takes a data model (see Entity Annotations) as input and generates structs, a data model representation as code and additional glue code for a tight and fast integration of your individual data types and the ObjectBox API.

If you are using CMake, it's highly recommended to use the CMake integration of the ObjectBox Generator. For all other setups, triggering the generator in standalone mode is also supported.

info
The ObjectBox Generator binary is currently not available for Linux/Windows ARM architectures (pull requests are welcome). The macOS as universal binary supports ARM64 and AMD64 architectures.

CMake Integration
The ObjectBox Generator is well integrated into CMake.

Enabling the Generator via CMake

Once you have the ObjectBox runtime library set up via FetchContent (see installation), it only takes one more command to enable the Generator:

# Note: downloads automatically if not found locally
find_package(ObjectBoxGenerator 4.0.0 REQUIRED)

With that, the CMake function add_obx_schema is now available (see next section).

Add the schema with add_obx_schema
This function “adds” ObjectBox schema files (.fbs) to a C++ CMake target. This implies generating a C++ source and header file for each given schema file. On a CMake level, the C++ sources are added to the CMake target and a dependency to the schema file is registered.

add_obx_schema(
  TARGET <target>
  SCHEMA_FILES <schemafile>..
  [INSOURCE]
  [OUTPUT_DIR <path>]
  [OUTPUT_DIR_HEADERS <path>]
  [OUTPUT_DIR_MODEL_JSON <path>]
  [CXX_STANDARD 11|14]
  [EXTRA_OPTIONS <options>..]
)


add_obx_schema: Options
Note: The parameters TARGET and SCHEMA_FILES are required.

TARGET specifies the CMake target to which the generated sources shall be assigned to.

SCHEMA_FILES takes one or multiple ObjectBox schema file(s). A schema file is the input for the ObjectBox Generator and defines classes and their members. For details on the schema file please refer to the documentation. Schema files have the pattern <name>.fbs. For each schema file, the generator creates a C++ source and header file using the pattern <name>.obx.cpp and <name>.obx.hpp, respectively. (Also, two model files are generated: objectbox-model.h and a objectbox-model.json.)

The option INSOURCE tells the generator to place all generated files in the source tree (directory). Note, that by default, the generator writes the generated C/C++ sources to the CMake build dir. It’s often preferable to use INSOURCE, as it can have several advantages:

It makes the generated sources more “visible” to developers.
It allows checking in generated sources to version control.
It does not require a generator setup for consumers, e.g. after checkout.
One caveat with INSOURCE is that a cmake clean (cmake –target clean) also deletes the generated in-source files. This may change with a later version.

OUTPUT_DIR specifies the location for auto-generated files in the source tree (default: current source directory). For in-source (INSOURCE) builds, this affects all generated files. For out-of-source builds, it only affects the objectbox-model.json file, because must be be kept in-source. The given directory can be relative to current source directory or can be given as absolute path.

OUTPUT_DIR_HEADERS sets the output directory for generated header files for INSOURCE builds. It can be used alongside OUTPUT_DIR and then “overwrites” the directory for headers (only). Note that for in-source builds, the configured include-directories for the target are not changed. Thus, you need to specify the paths in the include statements, or add the include directory manually. (Out-of-source builds add the internally used directory for headers as an include directory to the target.)

The option OUTPUT_DIR_MODEL_JSON specifies the location of the generated objectbox-model.json file. It defaults to current source directory, or OUTPUT_DIR if it is given. This generated file must be maintained under version source control since it is essential maintain database schema changes over time.

Supply the option CXX_STANDARD to generate sources complying to a lower C++ standard, i.e. 11 for C++11. By default, and when 14 is given, the generator creates sources compatible with C++14 and higher versions.

The option EXTRA_OPTIONS may pass additional arguments directly to the code generator executable (e.g. “-empty-string-as-null -optional std::shared_ptr”)

Out-of-source configuration
By default, generated files (except the model JSON file) are written relative to the current binary (build) directory. Generated headers and sources are written to the sub-directories ObjectBoxGenerator-include and ObjectBoxGenerator-src, respectively.

Details on finding the CMake module
The CMake module is implicitly downloaded together with objectbox shared libraries as described in Installation.

The latest version of the find module is also available from https://raw.githubusercontent.com/objectbox/objectbox-generator/main/cmake/FindObjectBoxGenerator.cmake

info
Automatic download of ObjectBox-Generator executables can be disabled via CMake Option OBX_GENERATOR_ALLOW_FETCH set to FALSE.

The generator repository provides a CMake find module for find_package .

This find module automatically locates a local installation of the executable objectbox-generator and checks it against the requested version. In addition, it can automatically download a version into the build directory. Automatic download is enabled by default via the option OBX_GENERATOR_ALLOW_FETCH. To turn this behaviour off, run cmake configure with e.g. cmake -DOBX_GENERATOR_ALLOW_FETCH=OFF ...

Currently supported platforms are Linux/x86-64, macOS and Windows/x86-64.

find_package(ObjectBoxGenerator 4.0.0 REQUIRED)Variables

The following variables are defined by this module:

ObjectBoxGenerator_FOUND

Whether objectbox-generator was successfully found.

ObjectBoxGenerator_EXECUTABLE

If found, this variable comprises the full path to executable.

ObjectBoxGenerator_VERSION

The full version string of the used ObjectBox Generator executable, e.g. “4.0.0” or “4.0.0-alpha2”.

ObjectBoxGenerator_VERSION_MAJOR
ObjectBoxGenerator_VERSION_MINOR
ObjectBoxGenerator_VERSION_PATCH

The major, minor and patch version parts of the used ObjectBox Generator executable.

Using the Standalone Generator
ObjectBox Generator can be downloaded as an executable (or build from GitHub). To trigger the generator, you simply run it using CLI parameters.

C and C++ Standard compliance
To generate for plain C, use the -c switch. The C++ default output mode (using option switch -cpp) generates code targeting C++14 or higher. If you need to generate C++11 compliant code use -cpp11 instead.

C++ Advanced Options
-empty-string-as-null: Empty strings are treated as null values in flatbuffers binary representation.
-nan-as-null: NaN (Not-A-Number) float32/float64 values are treated as null values in flatbuffers binary representation.
-optional std::optional|std::unique_ptr|std::shared_ptr: C++ wrapper type to use for fields annotated with optional .
Embedded flatc compiler
The ObjectBox Generator is distributed as self-contained portable binary for Linux, Windows and macOS platforms, written in Go.
As a goodie it encapsulates a fully functional flatc compiler for generic flatbuffers tooling - comprising over a dozen language bindings. Use the compiler by providing FLATC as first option, passing the rest of arguments to the embedded flatc:

objectbox-generator FLATC <flat arguments>

See all available options via objectbox-generator FLATC --help

Example generic flatbuffers usage:

objectbox-generator FLATC --cpp --rust monster.fbs

Help command
Run ./objectbox-generator --help for a list of current CLI parameters. The output looks something like this:

Usage:
  objectbox-generator [flags] {path}
      * to execute "clean" action (see below) on the path, removing previously generated code and missing entities,
      * and execute code generation on the path afterwards.

      The given {path} can be one of the following:
        * a directory - a non-recursive clean and generation is performed on the given directory,
        * a glob path pattern (e.g. contains a "*") - performs clean and generation on the matching paths,
        * a Go-style path pattern (e.g. "./..." - a recursive match of the current dir) - performs clean and generation on the matching paths,


or
  objectbox-generator [flags] {model/file/path.fbs}
      to generate the binding code for a single file


or
  objectbox-generator [flags] clean {path}
      to remove the generated files instead of creating them - this removes *.obx.* and objectbox-model.h but keeps objectbox-model.json

or
  objectbox-generator FLATC [flatc arguments]
      to execute FlatBuffers flatc command line tool Any arguments after the FLATC keyword are passed through.

path:
  * a source file path or a valid path pattern (e.g. ./...)
  
Available flags:
  -c    generate plain C code
  -cpp
        generate C++ code (at least C++14)
  -cpp11
        generate C++11 code
  -empty-string-as-null
        C++: empty strings are treated as 0 (null)
  -go
        generate Go code
  -help
        print this help
  -model string
        path to the model information persistence file (JSON)
  -nan-as-null
        C++: NaNs are treated as 0 (null)
  -optional string
        C++ wrapper type to use for fields annotated "optional"; one of: std::optional, std::unique_ptr, std::shared_ptr
  -out string
        output path for generated source files
  -out-headers string
        optional: output path for generated header files
  -persist string
        [DEPRECATED, use 'model'] path to the model information persistence file (JSON)
  -version
        print the generator version info
m


Store
The "Store" is typically your first touching point with the ObjectBox API. It represents a database you can open and get further API object to interact with it.

Store Options
When creating a store, you can provide additional options like the database model aka schema, the location of the database or a maximum size. In the following, we'll show some of the most important options (check the API docs for a complete list).

Model
The model specifies available entities in an ObjectBox database. It is usually specified using FlatBuffer IDL files processed by the ObjectBox Generator to output a objectbox-model.h header file for C and C++ users.

C++
C
#include "objectbox-model.h"
OBX_model* model = create_obx_model();

obx::Options options(model);
obx::Store store(options);

Storage Location
ObjectBox persists data per default to files in a directory named "objectbox". Use the following option to configure the directory to your application needs.

C++
C
obx::Options options(model);
options.directory("resources/mydb");
obx::Store store(options);

In-Memory Databases
info
Available since v0.21.0

You can use ObjectBox also for non-persistent in-memory databases. To create a memory-backed store, use the directory prefix "memory:" and pick a name for the database to address it, e.g. “memory:myApp”. Apart from the special prefix, it's using the same "directory" option call:

C++
C
obx::Options options(model);
options.directory("memory:myApp");
obx::Store store(options);

Note: in-memory databases are kept after closing a store; they have to be explicitly deleted or are automatically deleted if the creating process exists.

Typical applications are caching and using ObjectBox as an advanced in-memory data structure with all the benefits of using FlatBuffer objects, transactions, relations, querying, etc.... For more details, check out our blog post on in-memory use cases.

Read-Only Access
Setting a database to read-only access only.

info
Advanced Setting: Use previous commit

Recommended to be used together with read-only mode to ensure no data is lost. Ignores the latest data snapshot (committed transaction state) and uses the previous snapshot instead. When used with care (e.g. backup the DB files first), this option may also recover data removed by the latest transaction. Defaults to false.

C++
C
obx::Options options(model);
options.readOnly(true)
       .usePreviousCommit(true); 
obx::Store store(options);

File Mode
Specify unix-style file permissions for database files. This parameter is ignored on Windows platforms.

C++
C
obx::Options options(model);
options.fileMode(0640); 
obx::Store store(options);

Maximum Resource Limits
Several limitations regarding the resources of a Store can be specified.

C++
C
obx::Options options(model);
options
  .maxDbSizeInKb(4*1024*1024)
  .maxDataSizeInKb(4*1024*1024)
  .maxReaders(256);
obx::Store store(options);

Maximum Database Size
maxDbSizeInKb sets the maximum size the database file can grow to. When applying a transaction (e.g. putting an object) would exceed, it an exception is thrown (C++) or error is returned (C).
By default, this setting is 1 GB, which should be sufficient for most applications. In general, a maximum size prevents the database from growing indefinitely when something goes wrong (for example data is put in an infinite loop).
This value can be changed, so increased or also decreased, each time when opening a store.

Maximum Data Size
maxDataSizeInKB can be set to limit the actual storage of data, excluding system and metadata, in contrast to maxDbSizeInKB. Thus, it must be less than the maximum database size.

info
This resource limitation tracker is more involved. Only use this if a stricter, more accurate limit is required.

Maximum Number of Readers
A "Reader" is short for a thread involved in a read transaction. Readers are an finite resource for which we need to define a maximum number upfront. maxReaders sets the maximum number of concurrent readers. The default value (about 126 readers) is enough for most apps and usually you can ignore it completely. However, if the maximum is exceeded the store throws an exception or reports an error (OBX_ERROR_MAX_READERS_EXCEEDED). In this case check that your code only uses a reasonable amount of threads.

For highly concurrent setups (e.g. you are using ObjectBox on the server side) it may make sense to increase the number.

info
The internal default is currently 126. So when hitting this limit, try values around 200-500.

Each thread that performed a read transaction and is still alive holds on to a reader slot. These slots only get vacated when the thread ends. Thus, be mindful with the number of active threads.

Consistency and Validation 
ObjectBox offers several maintenance checks for validation and consistency checking. When the DB is opened initially, ObjectBox can do a

consistency check on (branch and leaf) database pages
validation over the key/value pairs to check
C++
C
obx::Options options(model);
options
  .validateOnOpenPages(1, OBXValidateOnOpenPagesFlags_VisitLeafPages)
  .validateOnKV();
obx::Store store(options);

validateOnOpenPages enables a consistency check on the given amount of pages. To completely disable this test you can pass 0, but we recommend a setting of at least 1. Optional flag VisitLeafPages enable validation of leaf pages (by default only branch pages are validated).

info
Reliable file systems already guarantee consistency, so this is primarily meant to deal with unreliable OSes, file systems, or hardware. Thus, usually a low number (e.g. 1-20) is sufficient and does not impact startup performance significantly.

Note: ObjectBox builds upon ACID storage, which guarantees consistency given that the file system is working correctly (in particular fsync).

validateOnKV enables validation over the key/value pairs to check, for example, whether they're consistent towards our internal specification. The flags argument is currently an empty enum (except None) for future improvments.

Tuning Asynchronous Operations
Fine-tune asynchronous operations using functions prefixed with obx_opt_async_ (C) and Options::async (C++).

C++
C
obx::Options options(model);
options.asyncMaxInTxDuration(1000);
obx::Store store(options);

Available options for fine-tuning asynchronous operations:

MaxInTxDuration (micros): Max. duration spent in a transaction before queue enforces a commit.
MaxInTxOperations (number of ops): Max. Ops performed in a transaction before queue enforces a commit. This becomes relevant if the queue is constantly populated at a high rate.
MaxQueueLength (size): Max. size of queue.
MaxTxPoolSize (size): Default 10000, set to 0 to deactivate pooling.
MinorRefillMaxCount (size): If non-zero, this allows "minor refills" with small batches that came in (off by default).
MinorRefillThreshold (size): Numbers of operations below this value are considered "minor refills".
ObjectBytesMaxCacheSize (size): Total cache size; default: ~ 0.5 MB.
ObjectBytesMaxSizeToCache (size): Maximal size for an object to be cached (only cache smaller ones),
PreTxnDelay (micros): Delay before starting transactions when queue is triggered (e.g. gives a newly starting producer some time to produce more than one a single operation before queue starts.) Note: This value should typically be low to keep latency low and prevent accumulating too much operations.
PostTxnDelay (micros): Similar to PreTxDelay but after a transaction was committed. One of the purposes is to give other transactions some time to execute. In combination with
PreTxDelay this can prolong non-TX batching time if only a few operations are around.
ThrottleAtQueueLength(size): Producers (AsyncTx submitter) is throttled when the queue size hits this.
ThrottleMicros (micros): Sleeping time for throttled producers on each submission.
Debug Flags
When debugging or fine-tuning performance you can enable logging of various events at the info level.

C++
C
obx::Options options(model);
options.addDebugFlags(
  OBXDebugFlags_LOG_TRANSACTIONS_READ
| OBXDebugFlags_LOG_TRANSACTIONS_WRITE
);
obx::Store store(options);

Using the Store
Once you created the store, it gives you access to several ways to interact with the data you store in it; aka the database:

Box API: easy to use object-based API with implicit transactions. It is used in combination with the ObjectBox Generator, which generates the source code for data and Box classes. Check the getting started track for examples.
Query API: In combination with the Box API, you can build powerful queries using the query builder. Once built, query instances can be executed multiple times to retrieve data.
Explicit Transactions: Often it's a good idea to group several operations into a single "batch", or more precisely, one transaction. Batched transactions are not only faster, but also consider safe state changes for your data.




Queries
You can query the ObjectBox C / C++ database for objects by specifying criteria with the Query builder. It is easy, learn how to do it here.

ObjectBox queries return persisted objects that match user-defined criteria. You use QueryBuilder to specify criteria and create a Query which actually executes the query and returns matching objects.

Building queries
The QueryBuilder<T>/OBX_query_builder class lets you build custom queries for your entities. Create an instance via box.query() (C++) or obx_query_builder() (C).

The generated code contains entity and property meta-information in an enum (C) or a struct (C++). These provide a way to define query conditions safely, without literal entity and property IDs spread throughout the code. Let's have a look at a fragment of the generated code for a User entity (its unique Entity ID is 6 and it has three properties: id, name surname) and the examples below.

C++
C
struct User_ {
    static constexpr obx_schema_id entityId() { return 6; }
    
    static const obx::Property<User, OBXPropertyType_Long> id;
    static const obx::Property<User, OBXPropertyType_String> name;
    static const obx::Property<User, OBXPropertyType_String> surname;
};

Here's how we could query for all users with the first name “Joe” (case insensitive) and their surname starting with a capital "O". First, we initialize the QueryBuilder, next we add one or more conditions (combined with AND operator by default), then we build the query and finally execute it using find.

C++
C
QueryBuilder<User> qb = box.query(
        User_::name.equals("Joe", false) && User_::surname.startsWith("O")
        );
Query<User> query = qb.build();
std::vector<std::unique_ptr<User>> joes = query.find();

Reusing queries and parameters
If you frequently run a Query you should cache the Query object and re-use it. To make a Query more reusable you can change the values, or query parameters, of each condition you added even after the Query is built. Let's see how.

Assume we want to find a list of User with specific name values. First, we build a regular Query with an equal condition for name. Because we have to pass an initial parameter value to equal() but plan to override it before running the Query later, we just pass an empty string:

C++
C
Query<User> query = box.query(User::name.equals("")).build();

Now at some later point, we want to actually run the Query. To set a value for the name parameter on the Query and pass the name property and the new parameter value:

C++
C
// Change name param to "Joe", get results
auto joes = query.setParameter(User_::name, "Joe").find();

...

// Change name param to "Jake", get results
// Note: setting a parameter updates the query object so no need to do it inline
query.setParameter(User_::name, "Jake"); 
auto jakes = query.find();

Aliases
So you might already be wondering, what happens if you have more than one condition using the same property? For this purpose, you can assign each condition an alias by calling Alias() right after specifying the condition:

C++
C
obx_qb_int_greater(qb.cPtr(), User_::age, 0);
obx_qb_param_alias(qb.cPtr(), "min age");
obx_qb_int_less(qb.cPtr(), User_::age, 0);
obx_qb_param_alias(qb.cPtr(), "max age");

Then you'll pass the alias when setting a new parameter value:

C++
C
obx_query_int_param_alias(query.cPtr(), "min age", 50);
obx_query_int_param_alias(query.cPtr(), "max age", 100);

Limit, Offset, and Pagination
Sometimes you only need a subset of a query, for example, the first 10 elements. This is especially helpful (and frugal) when you have a high number of entities and you cannot limit the result using query conditions only. The built query has offset and limit methods to help you do that.

C++
C
auto users = query.offset(10).limit(5).find();
// users.size() <= 5

// same result on later calls, offset and limit are persisted on the C++ query
users = query.find(); 

Reading a single property
If you only want to return the values of certain property and not a list of full objects you can use a PropertyQuery:

C++
C
Query<User> query = qb.build();
OBX_query_prop* propQuery = obx_query_prop(query.cPtr(), User_::age);
OBX_int64_array* ages = obx_query_prop_int64_find(propQuery, nullptr);

info
Note: the returned array of property values is not in any particular order, even if you did specify an order when building the query.

Handling null values
By default, null values are not returned (they're skipped). However, you can specify a replacement value to return if a property is null as the second argument to obx_query_prop_*_find().

Other query features
There are many more features, such as property aggregate functions, distinct, removal of all data matching a query. Be sure to check out the objectbox.h and objectbox.hpp or API docs to discover more.


Relations
Learn how to create and update to-one and to-many relations between entities in ObjectBox C / C++ database.

Objects may reference other objects, for example using a simple reference or a list of objects. In database terms, we call those references relations. The object defining a relation we call the source object, the referenced object we call the target object. So a relation has a direction.

If there is one target object, we call the relation to-one. And if there can be multiple target objects, we call it to-many. Note, the direction of the relation matters, as there's also a link back in the reverse direction (the "backlink").

info
If you are familiar with 1:N and N:M relations, here are the corresponding object relations in ObjectBox:

1:N (one-to-many): to-one relation with its backlink
N:M (many-to-many): to-many relation with its backlink

To-One Relations


To-One Relation Schema Definition
You define a to-one relation by using the property annotation objectbox:relation=<TargetEntity> in the source entity definition.

schema.fbs
table Customer {
    id: ulong;
    name: string;
}

table Order {
    id: ulong;
    product: string;
    /// objectbox:relation=Customer
    customerId: ulong;
}

Queries using Relation Links
You can use relations in queries to combine query conditions across multiple entity types. At the API level, this is done by following relations from the source to the target by calling a link(<RelationProperty>) method on the Query Builder which returns new a Query Builder suitable to express conditions on the target entity.

Example for finding all "Potato" orders by customers who's name starts with "O":

C++
C
QueryBuilder<Order> qb = ordersBox.query( Order_::product.equals("Potato") );
QueryBuilder<Customer> qbCustomer = qb.link( Order_::customerId );
qbCustomer.with( Customer_::name.startsWith("O") );
auto orders = qb.build().find(); 

To-One Backlinks
A to-one relation implies a direction. For example, when an order is made by a customer, it's the order that points to a customer (via a customer ID). However, in ObjectBox, relations are always bidirectional. Thus, we can also use the reverse direction, which we call the backlink of a relation. In the case of the "order -> customer" to-one relation, its backlink is "customer -> order". Note that one customer can have multiple orders, and thus we can say that the backlink is actually a "one-to-many" (1:N) relation.

Queries using Relation Backlinks
To create a query following the backlink (the "reverse" direction), you can call backlink(<RelationProperty>) on the Query Builder starting from the "target entity" of the to-one relation. Analog to link, a Query Builder is returned to extend the query expression by conditions on the source entity.

Example for finding all customers with their name starting with "O" and who ordered potatoes:

C++
C
QueryBuilder<Customer> qb = customersBox.query( Customer_::name.startsWith("O") );
QueryBuilder<Order> qbOrder = qb.backlink( Order_::customerId );
qbOrder.with( Order_::product.equals("Potato") );
auto customers = qb.build().find();

Many-To-Many Relations


To-Many Relation Schema Definition
You define a many-to-many relation by using the entity annotation objectbox:relation(name=<SourceRelFieldName>,to=<TargetEntity>)and apply it on source entity definition.

schema.fbs
table Teacher {
    id: ulong;
    name: string;
}

/// objectbox:relation(name=teachers,to=Teacher)
table Student {
    id: ulong;
    name: string;
}

Setting Many-to-Many Relations
In contrast to to-one relations, many-to-many relations are stored "standalone" (not inside the objects themselves). Thus, a separate set of API calls exists for put, get and remove.

Example for putting a "teachers" relation from Student "Ferris" to Teacher "Rooney".

C++
C
students.standaloneRelPut<Teacher>(Student_::teachers, id_ferris, id_mr_rooney );  

Query with Many-to-Many Relations
Similar to To-One relations, building queries across relation links is done using the same link / backlink API style (see the to-section for basics and details).

Example for finding all students of Teacher "Rooney":

C++
C
QueryBuilder<Students> qb = studentsBox.query();
QueryBuilder<Teacher> qbTeacher = qb.link<Teacher>(Student_::teachers);
qbTeacher.with(Teacher_::name.equals("Rooney"));
auto students = qb.build().find();

Example for finding all teachers of Student "Ferris":

C++
C
QueryBuilder<Teacher> qb = teachers.query();
QueryBuilder<Students> qbStudents = qb.backlink<Student>(Student_::teachers);
qbStudents.with(Student_::name.equals("Ferris"));
auto teachers = qb.build().find();


Transactions
The ObjectBox database is transactional and fully ACID compliant. ObjectBox gives developers Multiversion concurrency control (MVCC) semantics.

What is a database transaction?
A transaction groups several operations into a unit of work. This unit of work (transaction) can either execute completely or not at all, but it cannot be "half-completed". Thus, you always know the status of your data. By definition a transaction must be ACID: A = atomic (either entirely completed or without any effect), consistent (conforming to existing constraints in the database), isolated (not affecting other transactions) and durable (persisted). This definition is based on Wikipedia, where you can dive deeper on database transactions, if that is what you are looking for.

ObjectBox is transactionally safe
Nearly all interactions with ObjectBox involve transactions, e.g. when you call Box put() a write transaction is used. Or for example, a read transaction is used, when you count() objects in a box. All of this is transparent to you, while you don't need to take care of it yourself.

In C++, it may be fine to completely ignore transactions altogether in your app without running into any problems. In C, you will need to use explicit transactions in some situations, such as reading objects.

Understanding the transaction basics can help you to make your app more consistent and efficient, especially if you are working on a complex application.

Explicit transactions
An implicit transaction is a transaction that is started automatically. An explicit one is started by a call to store.tx()/obx_txn_write(store)and is active until marked successful or aborted. By default, all Box operations run in implicit transactions unless an explicit transaction is in progress on the same thread. In the latter case, multiple operations share the (explicit) transaction. This means:

info
With explicit transactions, you control the transaction boundary. You can use this to improve efficiency and consistency in your app.

Advantages of explicit database transactions:

you can perform any number of operations and use objects of multiple boxes, while having a consistent view of the data,
running multiple updates/inserts is faster because it doesn't involve starting an implicit transaction each time,
being able to "roll-back" a transaction when an error occurs, potentially discarding changes from multiple updates.
Example for a write transaction which just inserts 1 000 000 objects (assumes an opened store & box):

C++
C
obx::Transaction tx = store.txWrite();
for (int i = 1000000; i > 0; i--) {
    box.put({});
}
tx.success();

Understanding transactions is essential to mastering the database performance. If you just remember one sentence on this topic, it should be this one: a write transaction has its price, and it's the same whether it's implicit or explicit.

Committing a transaction involves syncing data to physical storage, which is a relatively expensive operation for databases. Only when the file system confirms that all data has been stored in a durable manner (not just memory cached), the transaction can be considered successful. This file sync required by a transaction may take a couple of milliseconds. Keep this in mind and try to group several operations (e.g.putcalls) in one transaction.

Read Transactions
In ObjectBox, read transactions are very cheap. Unlike write transactions, there is no commit and thus no expensive sync to the file system. Operations like get , count , and queries run inside an implicit read transaction if they are not called when already inside an explicit transaction (read or write). Note that it is illegal to put (or do any other write operation) when inside a read transaction.

While read transactions are cheaper than write transactions, there is still some overhead to start one. Thus, for a high number of reads (e.g. hundreds, in a loop), you can improve performance by grouping those reads in a single read transaction (see explicit transactions above).

Multiversion concurrency
ObjectBox gives developers Multiversion concurrency control (MVCC) semantics. This allows multiple concurrent readers (read transactions) which can execute immediately without blocking or waiting. This is guaranteed by storing multiple versions of (committed) data. Even if a write transaction is in progress, a read transaction can read the last consistent state immediately. Write transactions are executed sequentially to ensure a consistent state. Thus, it is advised to keep write transactions short to avoid blocking other pending write transactions. For example, it is usually a bad idea to do networking or complex calculations while inside a write transaction. Instead, do any expensive operation and prepare objects before entering a write transaction.

Note that you do not have to worry about making write transactions sequential yourself. If multiple threads want to write at the same time, one of the threads will be selected to go first, while the other threads have to wait. It works just like mutex locks.

Locking inside a Write Transaction
danger
Avoid locking (e.g. with a mutex) when inside a write transaction when possible.

Because write transactions run exclusively, they effectively acquire a write lock internally. As with all locks, you need to pay close attention when multiple locks are involved. Always obtain locks in the same order to avoid deadlocks. If you acquire a lock “X” inside a transaction, you must ensure that your code does not start another write transaction while having the same lock “X”.

Schema Changes
The ObjectBox C / C++ database comes with automatic schema migration. Learn all about it here.

ObjectBox manages its data model (schema) mostly automatically. The data model is defined by the Entities you define in FlatBuffer schema files. When you add or remove entities or properties of your entities, ObjectBox takes care of those changes when you launch objectbox-generator on the changed .fbs file without any further action needed from you.

For other changes like renaming or changing the type, ObjectBox needs extra information to make things unambiguous. This works using unique identifiers (UIDs) specified by the uid annotation, as we will see below.

Renaming Entities and Properties 
So why do we need that UID annotation? If you simply rename an entity, ObjectBox only sees that the old entity is gone and a new entity is available. This can be interpreted in two ways:

The old entity is removed and a new entity should be added, the old data is discarded. This is the default behavior of ObjectBox.
The entity was renamed, the old data should be re-used.
So to tell ObjectBox to do a rename instead of discarding your old entity and data, you need to make sure it knows that this is the same entity and not a new one. You do that by attaching the internal UID to the entity. The same applies when renaming properties. We'll show an example for both an entity and a property rename.

Step 1: Add an empty objectbox:uid annotation to the entity/property you want to rename:

schema.fbs
/// objectbox:uid
table OldEntityName {
    id: ulong;
}

table Task {
    id: ulong;
    /// objectbox:uid
    old_property_name: string;
}

Step 2: Re-generate ObjectBox code for the file using objectbox-generator [-c|-cpp] schema.fbs. The generation will fail with an error message that gives you the current UID of the entity/property:

output for empty uid annotation on an entity
can't merge model information: entity OldEntityName: uid annotation value must 
not be empty (model entity UID = 8427767268318374108) on entity OldEntityName

output for empty uid annotation on a property
can't merge model information: merging entity Task: property old_property_name: 
uid annotation value must not be empty:
    [rename] apply the current UID 7671517997700696229
    [change/reset] apply a new UID 2346823240790844685

info
Note how for a property, the output is slightly different. It's because you have two options, either renaming the property or resetting (clearing) it's stored data. See Reset data - new UID on a property for more details.

Step 3: Apply the UID printed in the error message to your entity/property:

/// objectbox: uid=8427767268318374108
table OldEntityName {
    id: ulong;
}

table Task {
    id: ulong;
    /// objectbox:uid=7671517997700696229
    old_property_name: string;
}

Step 4: The last thing to do is the actual rename on the language level:

/// objectbox: uid=8427767268318374108
table RenamedEntity {
    id: ulong;
}

table Task {
    id: ulong;
    /// objectbox:uid=7671517997700696229
    renamed_property: string;
}

You can now use your renamed entity/property as expected and all existing data will still be there.

Note: Instead of the above you can also find the UID of the entity/property in the objectbox-model.json file yourself and add it as a value of the uid annotation when renaming your entity/property to achieve the same effect.

Changing Property Types
warning
ObjectBox does not support migrating existing property data to a new type. You will have to take care of this yourself, e.g. by keeping the old property and adding some migration logic.

New property, different name
It's just adding an additional property - this solution useful if you need to do the data migration manually or just want to keep the old data around.

table Task {
    id: ulong;
    old_property: string;
}

// becomes

table Task {
    id: ulong;
    old_property: string;
    new_property: int;
}

// Note, if the property already had an UID annotation, 
//  don't add the same UID to the new property - skip the annotation instead.

Reset data - new UID on a property
This solution useful if you don't care about the original data at all = it will be lost.

Step 1: Add an empty `objectbox:"uid"` annotation to the property you want to reset:

table Task {
    id: ulong;
    /// objectbox:uid
    text: string;
}

Step 2: Re-generate ObjectBox code for the project using go generate ./... in your project directory. The generation will fail with an error message that gives you the current UID of the property:

can't merge model information: merging entity Task: property text: 
uid annotation value must not be empty:
    [rename] apply the current UID 7671517997700696229
    [change/reset] apply a new UID 2346823240790844685

Step 3: Apply the UID printed in the error message to your property (and change its type):

table Task {
    id: ulong;
    /// objectbox: uid=2346823240790844685
    text: string;
}

You can now use the property in your entity as if it was a new one (no data stored)

Time Series Data
ObjectBox TS is the ObjectBox database extended by time series data. Ingestion of time based data and querying it is extremely optimized and efficient.

ObjectBox TS stores time series data differently to optimize handling of time based data. Assuming you are already familiar with the standard ObjectBox database, here's how to work with time series data in a nutshell:

For a time series enabled type, you annotate a date property as an ID companion
Standard queries targeting the ID companion date property will perform much better automatically
There are a couple of special APIs for time series operations, e.g. a time based iterator over data
info
Also check out the ObjectBox TS example project on GitHub.

Defining the Time Series type
Assuming you are already working with ObjectBox Generator (see getting started), you already know about FlatBuffer schema files and how to generate glue code to work conveniently with ObjectBox. Let's have a look at this simple definition file:

timeseries.fbs
table SensorData {
    id:ulong;

    /// objectbox:id-companion, date-nano
    time:long;

    valueName:string;
    
    value:long;
}

The type SensorData allows capturing values which come with a timestamp (time) and a name. While this mostly a standard definition, pay special attention to the annotations on the time property: objectbox:id-companion, date-nano tells ObjectBox that this is a time series enabled type. Also note that we are using nanosecond resolution (specifying date instead of date-nano would result in millisecond resolution). OK, this is all it needs to get the generator started:

objectbox-generator -cpp timeseries.fbs

This will generate all code you need to get started with C++ and time series objects.

Working with Time Series data
Time series data is inserted (put) like any other data:

obx::Box<Sensor> box(store);
obx_id id = box.put({.valueName = "temperature", .value = 36});

Note that the time property is absent and thus is automatically assigned to the current time. Of course, you can initialize time beforehand if e.g. the sensor offers a timestamp. Also, you like in standard ObjectBox, we did not assign an ID as this is done for you.

Internally, however, data is stored differently. Most importantly, there is no secondary index for the time property that has to be updated. The advantages of not requiring an secondary index are superior speed and less storage space.

warning
Time series data do not allow updates to the time property. As time series data is usually "immutable", this is typically not an issue. If you must update an object's time, remove the object, set its ID to 0, set the new time and put it. This results in a new object with a new ID.

In many ways time series objects work like regular objects. You can get and remove them, or query for them. The API stays the same.

Example Time Series project
For a more complex working example, visit the official ObjectBox TS C++ example project on GitHub. It's a ready to go setup; all you need is the ObjectBox TS library (contact us).
